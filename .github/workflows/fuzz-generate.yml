# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# fuzz-generate.yml â€” Weekly fuzz-test kindling generate against
# real-world repos. Full e2e: generate â†’ static analysis â†’
# docker build â†’ deploy DSE CRs to Kind â†’ cross-service
# networking validation from inside pods.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
name: Fuzz Test â€“ kindling generate

on:
  # schedule:
  #   - cron: "0 8 */2 * *"  # every other day, revert when push trigger removed
  push:
    branches: [main]
  workflow_dispatch:
    inputs:
      repos_override:
        description: "Comma-separated repo URLs (leave blank to use repos.txt)"
        required: false
        type: string
      provider:
        description: "LLM provider (openai or anthropic)"
        required: false
        default: "openai"
        type: string
      skip_e2e:
        description: "Skip cluster deploy, static analysis only"
        required: false
        default: "0"
        type: string

permissions:
  contents: read
  issues: write

env:
  FUZZ_CLUSTER: "fuzz"

jobs:
  fuzz:
    runs-on: ubuntu-latest
    timeout-minutes: 180

    steps:
      # â”€â”€ Setup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Checkout kindling
        uses: actions/checkout@v4

      - name: Set up Go
        uses: actions/setup-go@v5
        with:
          go-version-file: go.mod

      - name: Build kindling CLI
        run: |
          cd cli
          go build -ldflags "-s -w" -o ../bin/kindling .
          echo "${{ github.workspace }}/bin" >> "$GITHUB_PATH"

      - name: Verify kindling
        run: kindling version

      - name: Set up Python (for analyze.py)
        uses: actions/setup-python@v5
        with:
          python-version: "3.12"

      - name: Install Python deps
        run: pip install pyyaml

      # â”€â”€ Bootstrap Kind cluster with kindling operator â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Install Kind
        if: ${{ inputs.skip_e2e != '1' }}
        run: |
          [ -f /usr/local/bin/kind ] && kind version | grep -q 'v0.31' && exit 0
          curl -Lo /usr/local/bin/kind https://kind.sigs.k8s.io/dl/v0.31.0/kind-linux-amd64
          chmod +x /usr/local/bin/kind

      - name: Create Kind cluster
        if: ${{ inputs.skip_e2e != '1' }}
        run: |
          kind create cluster --name ${{ env.FUZZ_CLUSTER }} \
            --config kind-config.yaml \
            --wait 120s

      - name: Install ingress + registry
        if: ${{ inputs.skip_e2e != '1' }}
        run: bash setup-ingress.sh

      - name: Build and deploy kindling operator
        if: ${{ inputs.skip_e2e != '1' }}
        run: |
          # Build operator image
          docker build -t controller:latest .
          kind load docker-image controller:latest --name ${{ env.FUZZ_CLUSTER }}

          # Install CRDs
          kubectl apply -f config/crd/bases/

          # Deploy operator via kustomize
          cd config/manager && kustomize edit set image controller=controller:latest && cd ../..
          kustomize build config/default | kubectl apply -f -

          # Wait for operator
          kubectl rollout status deployment/kindling-controller-manager \
            -n kindling-system --timeout=120s

      - name: Verify cluster ready
        if: ${{ inputs.skip_e2e != '1' }}
        run: |
          kubectl get crd devstagingenvironments.apps.example.com
          kubectl get pods -n kindling-system
          echo "âœ… Kind cluster with kindling operator ready"

      # â”€â”€ Run fuzz harness â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Prepare repo list
        id: repos
        run: |
          if [ -n "${{ inputs.repos_override }}" ]; then
            echo "${{ inputs.repos_override }}" | tr ',' '\n' > /tmp/repos.txt
          else
            cp test/fuzz/repos.txt /tmp/repos.txt
          fi
          echo "count=$(grep -v '^\s*#' /tmp/repos.txt | grep -v '^\s*$' | wc -l | tr -d ' ')" >> "$GITHUB_OUTPUT"

      - name: Run fuzz harness
        env:
          FUZZ_PROVIDER: ${{ inputs.provider || 'openai' }}
          FUZZ_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          FUZZ_MODEL: ""
          OPENAI_API_KEY: ${{ secrets.OPENAI_API_KEY }}
          FUZZ_CLUSTER: ${{ env.FUZZ_CLUSTER }}
          SKIP_E2E: ${{ inputs.skip_e2e || '0' }}
        run: |
          chmod +x test/fuzz/run.sh
          mkdir -p /tmp/fuzz-results
          test/fuzz/run.sh /tmp/repos.txt /tmp/fuzz-results bin/kindling

      # â”€â”€ Collect results â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Capture cluster state (on failure)
        if: failure() && inputs.skip_e2e != '1'
        run: |
          mkdir -p /tmp/fuzz-results
          echo "=== Pods ===" > /tmp/fuzz-results/cluster-state.log
          kubectl get pods -A >> /tmp/fuzz-results/cluster-state.log 2>&1
          echo "=== DSEs ===" >> /tmp/fuzz-results/cluster-state.log
          kubectl get dse -A >> /tmp/fuzz-results/cluster-state.log 2>&1
          echo "=== Events ===" >> /tmp/fuzz-results/cluster-state.log
          kubectl get events --sort-by=.lastTimestamp | tail -50 >> /tmp/fuzz-results/cluster-state.log 2>&1

      - name: Upload results artifact
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: fuzz-results-${{ github.run_number }}
          path: /tmp/fuzz-results/
          retention-days: 30

      - name: Generate issue body
        if: always()
        id: issue
        run: |
          python3 - <<'PYEOF'
          import json, os, datetime

          output_dir = "/tmp/fuzz-results"
          summary_file = os.path.join(output_dir, "summary.json")
          results_file = os.path.join(output_dir, "results.jsonl")

          summary = {}
          if os.path.exists(summary_file):
              with open(summary_file) as f:
                  summary = json.load(f)

          results = []
          if os.path.exists(results_file):
              with open(results_file) as f:
                  for line in f:
                      line = line.strip()
                      if line:
                          try:
                              results.append(json.loads(line))
                          except json.JSONDecodeError:
                              pass

          today = datetime.date.today().isoformat()
          md = []
          md.append(f"## ğŸ”¬ Fuzz Test Results â€” {today}\n")
          md.append(f"**Run:** [#{os.environ.get('GITHUB_RUN_NUMBER', '?')}]"
                    f"({os.environ.get('GITHUB_SERVER_URL', '')}/{os.environ.get('GITHUB_REPOSITORY', '')}"
                    f"/actions/runs/{os.environ.get('GITHUB_RUN_ID', '')})\n")

          md.append("### Summary\n")
          md.append("| Metric | Count |")
          md.append("|--------|-------|")
          md.append(f"| Repos tested | {summary.get('total', '?')} |")
          md.append(f"| Generate OK | {summary.get('generate_ok', '?')} ({summary.get('generate_rate', '?')}) |")
          md.append(f"| Valid YAML | {summary.get('yaml_ok', '?')} |")
          md.append(f"| Static analysis clean | {summary.get('static_net_ok', '?')} |")
          md.append(f"| Docker build OK | {summary.get('build_ok', '?')} |")
          md.append(f"| Deploy (DSE) OK | {summary.get('deploy_ok', '?')} |")
          md.append(f"| **e2e networking OK** | **{summary.get('e2e_ok', '?')}** ({summary.get('e2e_rate', '?')}) |")
          md.append("")

          # e2e failures section
          e2e_issues = [r for r in results
                        if r.get("stage") == "e2e"
                        and r.get("status") == "fail"]
          if e2e_issues:
              md.append("### ğŸ”´ e2e Networking Failures\n")
              for r in e2e_issues:
                  repo_short = r["repo"].split("/")[-1]
                  issues = r.get("issues", [])
                  if isinstance(issues, list) and issues:
                      md.append(f"<details><summary><b>{repo_short}</b> â€” {len(issues)} failures</summary>\n")
                      for issue in issues:
                          md.append(f"- **{issue.get('type', '?')}** ({issue.get('service', '?')}): "
                                    f"{issue.get('detail', '')}")
                      md.append(f"\n</details>\n")
                  else:
                      md.append(f"- **{repo_short}**: {r.get('detail', '')[:200]}")
              md.append("")

          # Static analysis issues
          static_issues = [r for r in results
                           if r.get("stage") == "static_analysis"
                           and r.get("issues") and r.get("issues") != "[]"
                           and isinstance(r.get("issues"), list) and len(r["issues"]) > 0]
          if static_issues:
              md.append("### âš ï¸ Static Networking Issues\n")
              for r in static_issues:
                  repo_short = r["repo"].split("/")[-1]
                  md.append(f"<details><summary><b>{repo_short}</b> â€” {len(r['issues'])} issues</summary>\n")
                  for issue in r["issues"]:
                      icon = "ğŸ”´" if issue.get("severity") == "error" else "ğŸŸ¡"
                      md.append(f"- {icon} **{issue.get('type', '?')}** ({issue.get('service', '?')}): "
                                f"{issue.get('detail', '')}")
                  md.append(f"\n</details>\n")

          # Other failures
          failures = [r for r in results
                      if r.get("status") == "fail"
                      and r.get("stage") not in ("e2e",)]
          if failures:
              md.append("### âŒ Other Failures\n")
              for r in failures:
                  repo_short = r["repo"].split("/")[-1]
                  md.append(f"- **{repo_short}** â†’ `{r.get('stage', '?')}`: {r.get('detail', '')[:150]}")
              md.append("")

          body = "\n".join(md)
          with open("/tmp/issue-body.md", "w") as f:
              f.write(body)

          total = summary.get("total", 0)
          e2e = summary.get("e2e_ok", "?")
          title = f"Fuzz e2e results {today}: {e2e}/{total} repos networking clean"
          with open(os.environ.get("GITHUB_OUTPUT", "/dev/null"), "a") as f:
              f.write(f"title={title}\n")
          PYEOF

      - name: Create or update issue
        if: always()
        uses: peter-evans/create-or-update-comment@v4
        continue-on-error: true
        with:
          issue-number: ${{ vars.FUZZ_ISSUE_NUMBER || '' }}
          body-path: /tmp/issue-body.md

      - name: Create new issue (if no pinned issue)
        if: always() && !vars.FUZZ_ISSUE_NUMBER
        uses: peter-evans/create-issue-from-file@v5
        continue-on-error: true
        with:
          title: ${{ steps.issue.outputs.title }}
          content-filepath: /tmp/issue-body.md
          labels: |
            fuzz-test
            automated

      # â”€â”€ Cleanup â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Delete Kind cluster
        if: always() && inputs.skip_e2e != '1'
        run: kind delete cluster --name ${{ env.FUZZ_CLUSTER }} || true

