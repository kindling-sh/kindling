# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# kindling-deploy â€” Reusable composite action for deploying a
# DevStagingEnvironment CR via the build-agent sidecar.
#
# Generates the DSE YAML from inputs, triggers the sidecar's
# kubectl apply, and optionally waits for the deployment rollout.
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
name: "kindling-deploy"
description: "Deploy a DevStagingEnvironment CR via the build-agent sidecar"

inputs:
  name:
    description: "DSE metadata.name (typically <actor>-<service>)"
    required: true
  image:
    description: "Container image reference"
    required: true
  port:
    description: "Container port"
    required: true
  labels:
    description: "Extra labels as YAML block (indented under metadata.labels)"
    required: false
    default: ""
  env:
    description: "Extra env vars as YAML block (indented under spec.deployment.env)"
    required: false
    default: ""
  dependencies:
    description: "Dependencies as YAML block (indented under spec.dependencies)"
    required: false
    default: ""
  ingress-host:
    description: "Ingress hostname (leave empty to skip ingress)"
    required: false
    default: ""
  ingress-class:
    description: "Ingress class name"
    required: false
    default: "nginx"
  health-check-path:
    description: "HTTP health check path"
    required: false
    default: "/healthz"
  replicas:
    description: "Number of replicas"
    required: false
    default: "1"
  service-type:
    description: "Service type (ClusterIP, NodePort, LoadBalancer)"
    required: false
    default: "ClusterIP"
  wait:
    description: "Wait for deployment rollout (true/false)"
    required: false
    default: "true"
  wait-timeout:
    description: "Rollout wait timeout"
    required: false
    default: "180s"
  tunnel:
    description: "Route tunnel traffic to this service (set to 'true' to use the active kindling tunnel hostname as the ingress host)"
    required: false
    default: ""

runs:
  using: "composite"
  steps:
    - name: "Deploy ${{ inputs.name }}"
      shell: bash
      env:
        DSE_NAME: ${{ inputs.name }}
        DSE_IMAGE: ${{ inputs.image }}
        DSE_PORT: ${{ inputs.port }}
        DSE_LABELS: ${{ inputs.labels }}
        DSE_ENV: ${{ inputs.env }}
        DSE_DEPS: ${{ inputs.dependencies }}
        DSE_INGRESS_HOST: ${{ inputs.ingress-host }}
        DSE_INGRESS_CLASS: ${{ inputs.ingress-class }}
        DSE_HEALTH_PATH: ${{ inputs.health-check-path }}
        DSE_REPLICAS: ${{ inputs.replicas }}
        DSE_SVC_TYPE: ${{ inputs.service-type }}
        DSE_WAIT: ${{ inputs.wait }}
        DSE_WAIT_TIMEOUT: ${{ inputs.wait-timeout }}
        DSE_TUNNEL: ${{ inputs.tunnel }}
      run: |
        echo "ðŸš€ Deploying ${DSE_NAME}"

        # â”€â”€ Tunnel override â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        # If tunnel: true and a kindling tunnel is active, replace the
        # ingress host with the tunnel hostname so external traffic
        # (OAuth callbacks, webhooks, etc.) reaches this service.
        if [ "${DSE_TUNNEL}" = "true" ] && [ -n "${DSE_INGRESS_HOST}" ]; then
          TUNNEL_HOST=$(kubectl get configmap kindling-tunnel -o jsonpath='{.data.hostname}' 2>/dev/null || true)
          if [ -n "${TUNNEL_HOST}" ]; then
            echo "ðŸ”— Tunnel active â€” routing tunnel traffic to ${DSE_NAME}"
            echo "   ${DSE_INGRESS_HOST} â†’ ${TUNNEL_HOST}"
            DSE_INGRESS_HOST="${TUNNEL_HOST}"
          fi
        fi

        # â”€â”€ Generate DSE YAML â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        YAML_FILE="/builds/${DSE_NAME}-dse.yaml"

        cat > "${YAML_FILE}" <<DSEEOF
        apiVersion: apps.example.com/v1alpha1
        kind: DevStagingEnvironment
        metadata:
          name: ${DSE_NAME}
          labels:
            app.kubernetes.io/name: ${DSE_NAME}
            app.kubernetes.io/managed-by: kindling
        DSEEOF

        # Append extra labels if provided
        if [ -n "${DSE_LABELS}" ]; then
          echo "${DSE_LABELS}" | sed 's/^/    /' >> "${YAML_FILE}"
        fi

        cat >> "${YAML_FILE}" <<SPECEOF
        spec:
          deployment:
            image: ${DSE_IMAGE}
            replicas: ${DSE_REPLICAS}
            port: ${DSE_PORT}
            healthCheck:
              path: ${DSE_HEALTH_PATH}
        SPECEOF

        # Append env if provided
        if [ -n "${DSE_ENV}" ]; then
          echo "    env:" >> "${YAML_FILE}"
          echo "${DSE_ENV}" | sed 's/^/      /' >> "${YAML_FILE}"
        fi

        cat >> "${YAML_FILE}" <<SVCEOF
          service:
            port: ${DSE_PORT}
            type: ${DSE_SVC_TYPE}
        SVCEOF

        # Append ingress if host is set
        if [ -n "${DSE_INGRESS_HOST}" ]; then
          cat >> "${YAML_FILE}" <<INGEOF
          ingress:
            enabled: true
            host: ${DSE_INGRESS_HOST}
            ingressClassName: ${DSE_INGRESS_CLASS}
        INGEOF
        fi

        # Append dependencies if provided
        if [ -n "${DSE_DEPS}" ]; then
          echo "  dependencies:" >> "${YAML_FILE}"
          echo "${DSE_DEPS}" | sed 's/^/    /' >> "${YAML_FILE}"
        fi

        echo "ðŸ“„ Generated DSE:"
        cat "${YAML_FILE}"
        echo ""

        # â”€â”€ Apply via sidecar â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
        touch "${YAML_FILE%.yaml}.apply"
        WAITED=0
        while [ ! -f "${YAML_FILE%.yaml}.apply-done" ]; do
          sleep 1
          WAITED=$((WAITED+1))
          if [ ${WAITED} -ge 60 ]; then
            echo "âŒ Timed out waiting for sidecar to apply ${DSE_NAME}"
            exit 1
          fi
        done

        EXIT_CODE=$(cat "${YAML_FILE%.yaml}.apply-exitcode" 2>/dev/null || echo "1")
        if [ "${EXIT_CODE}" != "0" ]; then
          echo "âŒ Deploy ${DSE_NAME} failed:"
          cat "${YAML_FILE%.yaml}.apply-log" 2>/dev/null || true
          exit 1
        fi
        echo "âœ… ${DSE_NAME} applied"

    - name: "Wait for ${{ inputs.name }} rollout"
      if: ${{ inputs.wait == 'true' }}
      shell: bash
      env:
        DSE_NAME: ${{ inputs.name }}
        DSE_WAIT_TIMEOUT: ${{ inputs.wait-timeout }}
      run: |
        # Use sidecar for kubectl access
        cat > /builds/${DSE_NAME}-rollout.sh <<SCRIPT
        #!/bin/bash
        # Wait for the deployment to exist
        for i in \$(seq 1 30); do
          if kubectl get deployment/${DSE_NAME} >/dev/null 2>&1; then
            break
          fi
          sleep 2
        done
        kubectl rollout status deployment/${DSE_NAME} --timeout=${DSE_WAIT_TIMEOUT}
        SCRIPT
        chmod +x /builds/${DSE_NAME}-rollout.sh
        touch /builds/${DSE_NAME}-rollout.kubectl
        while [ ! -f /builds/${DSE_NAME}-rollout.kubectl-done ]; do sleep 2; done
        cat /builds/${DSE_NAME}-rollout.kubectl-log
        EXIT_CODE=$(cat /builds/${DSE_NAME}-rollout.kubectl-exitcode 2>/dev/null || echo "1")
        if [ "${EXIT_CODE}" != "0" ]; then
          echo "âš ï¸  Rollout for ${DSE_NAME} did not complete within timeout"
          echo ""

          # â”€â”€ Surface crash diagnostics â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
          # Grab the first pod's status + logs so the developer
          # sees *why* it failed right here in the CI output.
          echo "â”€â”€â”€ Pod status â”€â”€â”€"
          cat > /builds/${DSE_NAME}-diag.sh <<'DIAGSCRIPT'
          #!/bin/bash
          POD=$(kubectl get pods -l app.kubernetes.io/name=DSE_NAME_PLACEHOLDER \
                --sort-by=.metadata.creationTimestamp -o jsonpath='{.items[-1].metadata.name}' 2>/dev/null)
          if [ -z "$POD" ]; then
            echo "  No pods found for DSE_NAME_PLACEHOLDER"
            exit 0
          fi
          echo "  Pod: $POD"
          STATUS=$(kubectl get pod "$POD" -o jsonpath='{.status.containerStatuses[0].state}' 2>/dev/null)
          REASON=$(kubectl get pod "$POD" -o jsonpath='{.status.containerStatuses[0].state.waiting.reason}' 2>/dev/null)
          LAST_REASON=$(kubectl get pod "$POD" -o jsonpath='{.status.containerStatuses[0].lastState.terminated.reason}' 2>/dev/null)
          LAST_EXIT=$(kubectl get pod "$POD" -o jsonpath='{.status.containerStatuses[0].lastState.terminated.exitCode}' 2>/dev/null)
          [ -n "$REASON" ] && echo "  Status: $REASON"
          [ -n "$LAST_REASON" ] && echo "  Last terminated: $LAST_REASON (exit $LAST_EXIT)"
          echo ""
          echo "â”€â”€â”€ Last 30 log lines â”€â”€â”€"
          kubectl logs "$POD" --tail=30 2>/dev/null || echo "  (no logs available)"
          DIAGSCRIPT
          # Replace placeholder with actual name
          sed -i "s/DSE_NAME_PLACEHOLDER/${DSE_NAME}/g" /builds/${DSE_NAME}-diag.sh
          chmod +x /builds/${DSE_NAME}-diag.sh
          touch /builds/${DSE_NAME}-diag.kubectl
          DWAIT=0
          while [ ! -f /builds/${DSE_NAME}-diag.kubectl-done ]; do
            sleep 1
            DWAIT=$((DWAIT+1))
            if [ ${DWAIT} -ge 30 ]; then break; fi
          done
          cat /builds/${DSE_NAME}-diag.kubectl-log 2>/dev/null || true
        else
          echo "âœ… ${DSE_NAME} is running"
        fi
