package core

import (
	"os"
	"path/filepath"
	"testing"
)

// ────────────────────────────────────────────────────────────────────────────
// TunnelInfo / ReadTunnelInfo  (file-based round-trip)
// ────────────────────────────────────────────────────────────────────────────

func TestReadTunnelInfo(t *testing.T) {
	// Create a temp directory simulating .kindling/tunnel.yaml
	tmpDir := t.TempDir()
	kindlingDir := filepath.Join(tmpDir, ".kindling")
	if err := os.MkdirAll(kindlingDir, 0755); err != nil {
		t.Fatal(err)
	}

	content := `# Generated by kindling expose — do not edit
provider: cloudflared
url: https://abc123.trycloudflare.com
pid: 12345
created: 2024-01-01T00:00:00Z
`
	if err := os.WriteFile(filepath.Join(kindlingDir, "tunnel.yaml"), []byte(content), 0644); err != nil {
		t.Fatal(err)
	}

	// ReadTunnelInfo reads from cwd, so we chdir into tmpDir
	origDir, _ := os.Getwd()
	if err := os.Chdir(tmpDir); err != nil {
		t.Fatal(err)
	}
	defer os.Chdir(origDir)

	info, err := ReadTunnelInfo()
	if err != nil {
		t.Fatalf("ReadTunnelInfo() error = %v", err)
	}
	if info.Provider != "cloudflared" {
		t.Errorf("Provider = %q, want %q", info.Provider, "cloudflared")
	}
	if info.URL != "https://abc123.trycloudflare.com" {
		t.Errorf("URL = %q, want %q", info.URL, "https://abc123.trycloudflare.com")
	}
	if info.PID != 12345 {
		t.Errorf("PID = %d, want %d", info.PID, 12345)
	}
}

func TestReadTunnelInfo_NgrokProvider(t *testing.T) {
	tmpDir := t.TempDir()
	kindlingDir := filepath.Join(tmpDir, ".kindling")
	if err := os.MkdirAll(kindlingDir, 0755); err != nil {
		t.Fatal(err)
	}

	content := `provider: ngrok
url: https://abc123.ngrok-free.app
pid: 99999
`
	if err := os.WriteFile(filepath.Join(kindlingDir, "tunnel.yaml"), []byte(content), 0644); err != nil {
		t.Fatal(err)
	}

	origDir, _ := os.Getwd()
	os.Chdir(tmpDir)
	defer os.Chdir(origDir)

	info, err := ReadTunnelInfo()
	if err != nil {
		t.Fatalf("ReadTunnelInfo() error = %v", err)
	}
	if info.Provider != "ngrok" {
		t.Errorf("Provider = %q, want %q", info.Provider, "ngrok")
	}
	if info.URL != "https://abc123.ngrok-free.app" {
		t.Errorf("URL = %q, want %q", info.URL, "https://abc123.ngrok-free.app")
	}
	if info.PID != 99999 {
		t.Errorf("PID = %d, want %d", info.PID, 99999)
	}
}

func TestReadTunnelInfo_MissingFile(t *testing.T) {
	tmpDir := t.TempDir()
	origDir, _ := os.Getwd()
	os.Chdir(tmpDir)
	defer os.Chdir(origDir)

	_, err := ReadTunnelInfo()
	if err == nil {
		t.Error("expected error for missing tunnel.yaml")
	}
}

func TestReadTunnelInfo_EmptyFile(t *testing.T) {
	tmpDir := t.TempDir()
	kindlingDir := filepath.Join(tmpDir, ".kindling")
	os.MkdirAll(kindlingDir, 0755)
	os.WriteFile(filepath.Join(kindlingDir, "tunnel.yaml"), []byte(""), 0644)

	origDir, _ := os.Getwd()
	os.Chdir(tmpDir)
	defer os.Chdir(origDir)

	info, err := ReadTunnelInfo()
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if info.Provider != "" {
		t.Errorf("Provider = %q, want empty", info.Provider)
	}
	if info.URL != "" {
		t.Errorf("URL = %q, want empty", info.URL)
	}
	if info.PID != 0 {
		t.Errorf("PID = %d, want 0", info.PID)
	}
}

// ────────────────────────────────────────────────────────────────────────────
// ProcessAlive
// ────────────────────────────────────────────────────────────────────────────

func TestProcessAlive_CurrentProcess(t *testing.T) {
	// Our own PID should always be alive.
	if !ProcessAlive(os.Getpid()) {
		t.Error("ProcessAlive(own PID) = false, want true")
	}
}

func TestProcessAlive_NonExistent(t *testing.T) {
	// PID 0 is special on Unix — Signal(0) should fail on most systems.
	// Use a very high PID that's unlikely to exist.
	if ProcessAlive(9999999) {
		t.Error("ProcessAlive(9999999) = true, expected false for non-existent process")
	}
}

// ────────────────────────────────────────────────────────────────────────────
// ensureTunnelGitignored
// ────────────────────────────────────────────────────────────────────────────

func TestEnsureTunnelGitignored_NoGitignore(t *testing.T) {
	tmpDir := t.TempDir()
	ensureTunnelGitignored(tmpDir)

	data, err := os.ReadFile(filepath.Join(tmpDir, ".gitignore"))
	if err != nil {
		t.Fatalf("expected .gitignore to be created: %v", err)
	}
	if got := string(data); got != ".kindling/\n" {
		t.Errorf("content = %q, want %q", got, ".kindling/\n")
	}
}

func TestEnsureTunnelGitignored_ExistingWithoutEntry(t *testing.T) {
	tmpDir := t.TempDir()
	existing := "node_modules/\n*.log\n"
	os.WriteFile(filepath.Join(tmpDir, ".gitignore"), []byte(existing), 0644)

	ensureTunnelGitignored(tmpDir)

	data, _ := os.ReadFile(filepath.Join(tmpDir, ".gitignore"))
	content := string(data)
	if content != "node_modules/\n*.log\n.kindling/\n" {
		t.Errorf("content = %q", content)
	}
}

func TestEnsureTunnelGitignored_ExistingWithEntry(t *testing.T) {
	tmpDir := t.TempDir()
	existing := "node_modules/\n.kindling/\n*.log\n"
	os.WriteFile(filepath.Join(tmpDir, ".gitignore"), []byte(existing), 0644)

	ensureTunnelGitignored(tmpDir)

	data, _ := os.ReadFile(filepath.Join(tmpDir, ".gitignore"))
	content := string(data)
	// Should NOT be appended again
	if content != existing {
		t.Errorf("entry added again: %q", content)
	}
}

func TestEnsureTunnelGitignored_EntryWithoutSlash(t *testing.T) {
	tmpDir := t.TempDir()
	existing := ".kindling\n"
	os.WriteFile(filepath.Join(tmpDir, ".gitignore"), []byte(existing), 0644)

	ensureTunnelGitignored(tmpDir)

	data, _ := os.ReadFile(filepath.Join(tmpDir, ".gitignore"))
	content := string(data)
	// ".kindling" (without slash) should also prevent duplicate
	if content != existing {
		t.Errorf("entry added again: %q", content)
	}
}

func TestEnsureTunnelGitignored_NoTrailingNewline(t *testing.T) {
	tmpDir := t.TempDir()
	existing := "node_modules/"
	os.WriteFile(filepath.Join(tmpDir, ".gitignore"), []byte(existing), 0644)

	ensureTunnelGitignored(tmpDir)

	data, _ := os.ReadFile(filepath.Join(tmpDir, ".gitignore"))
	content := string(data)
	// Should add a newline before appending
	if content != "node_modules/\n.kindling/\n" {
		t.Errorf("content = %q", content)
	}
}

// ────────────────────────────────────────────────────────────────────────────
// TunnelInfo struct basics
// ────────────────────────────────────────────────────────────────────────────

func TestTunnelInfoZeroValue(t *testing.T) {
	var info TunnelInfo
	if info.Provider != "" || info.URL != "" || info.PID != 0 {
		t.Error("zero-value TunnelInfo should have empty fields")
	}
}

func TestTunnelResultZeroValue(t *testing.T) {
	var result TunnelResult
	if result.PublicURL != "" || result.PID != 0 || result.DNSOK {
		t.Error("zero-value TunnelResult should have empty/false fields")
	}
}

// ────────────────────────────────────────────────────────────────────────────
// CleanupTunnel (file removal only — no kubectl)
// ────────────────────────────────────────────────────────────────────────────

func TestCleanupTunnel_RemovesTunnelFile(t *testing.T) {
	tmpDir := t.TempDir()
	kindlingDir := filepath.Join(tmpDir, ".kindling")
	os.MkdirAll(kindlingDir, 0755)

	tunnelFile := filepath.Join(kindlingDir, "tunnel.yaml")
	os.WriteFile(tunnelFile, []byte("url: https://test.example.com\n"), 0644)

	origDir, _ := os.Getwd()
	os.Chdir(tmpDir)
	defer os.Chdir(origDir)

	// CleanupTunnel with empty clusterName just removes the file +
	// tries kubectl delete (which will fail silently in test).
	CleanupTunnel("")

	if _, err := os.Stat(tunnelFile); err == nil {
		t.Error("tunnel.yaml should have been removed")
	}
}
